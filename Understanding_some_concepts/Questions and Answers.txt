
1. Make a program that lets the user input a name
2. Get a number from the console and check if it’s between 1 and 10.

//Create a struct house with variables noRooms, price and city
//The golang example creates a new struct. Then it sets the variables.

package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type Person struct {
	name string
	job  string
}

type House struct {
	noRooms bool
	price   int
	city    string
}

func main() {
	var aperson Person

	aperson.name = "Albert"
	aperson.job = "Professor"

	fmt.Printf("aperson.name =  %s\n", aperson.name)
	fmt.Printf("aperson.job  =  %s\n\n", aperson.job)

	var inDaHouse House

	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Enter a price for the house: \n")

	pri, _ := reader.ReadString('\n')

	// remove newline
	pri = strings.Replace(pri, "\n", "", -1)

	// convert string variable to int variable
	price, e := strconv.Atoi(pri)
	if e != nil {
		fmt.Println("conversion error:", pri)
	}

	inDaHouse.noRooms = true
	inDaHouse.price = price
	inDaHouse.city = "Accra"

	fmt.Printf("Information on the house\n")
	fmt.Printf("Are there available rooms in the house? %v \n", inDaHouse.noRooms)
	fmt.Printf("The price is Ghc%d\n", inDaHouse.price)
	fmt.Printf("The house is located in %v \n", inDaHouse.city)
}

STRINGS

golang strings can be seen as a collection of characters. 
A string can be of length 1 (one character), but its usually longer. 
A string is always written in double qoutes.

To join strings, you can use the package strings which has the method .Join().

package main

import (
	"fmt"
	"strings"
)

func main() {
	s := strings.Join([]string{"hello", "world"}, ": ")
	fmt.Println(s)
}


SCOPES

Scope is where a variable can be used.

What’s the difference between a local and global variable?

A variable defined in the function is called a local variable. 
Their scope is only in the function body, that means they only exist within their function.

A variable defined outside the local scope is called a global variable. 
Global variables can be used throughout the package or even the external package (after export).

A variable in the function definition is called parameter



ARRAYS

An array is a set of numbered and length-fixed data item sequences that have the same unique type

This type can be any primitive type such as:

    integer
    string
    custom type

The array length must be a constant expression and must be a non-negative integer.

An array in the Go language is a type of value (not a pointer to the first element in C/C++), so it can be created by new():

var arr1 = new([5]int)

The array element can be read (or modified) by an index (position), the index starts from 0, 
the first element index is 0, the second index is 1, and so on.

fmt.Println(arr1[0]) // output first element

//Create an array with the number 0 to 10
//Create an array of strings with names

package main

import "fmt"

func main() {
	var a = []int64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	var names = []string{"Jasper", "Kojo", "Akabua"}

	b := len(a)

	fmt.Println(b)
	fmt.Println(names)
}


// Looping through an array
package main

import (
	"fmt"
)

func main() {
	// define array
	a := []int{1, 2, 3, 4, 5, 6}

	// loop over array
	for i := 0; i < len(a); i = i + 1 {
		fmt.Println("character :", a[i])
	}

	for b := 1; b < 11; b++ {
		fmt.Println(b)
	}
}


RANGE

Range iterates over elements. That can be elements of an array, elements of a dictionary or other data structures.

When using range, you can name the current element and current index: for i, num := range nums {.

But you are free to ignore the index: for _, num := range nums {.


package main

import "fmt"

func main() {
	nums := []int{1, 2, 3, 4, 5, 6}

	for _, num := range nums {
		fmt.Println(num)
	}

	var a = []int64{1, 2, 3, 4}

	for index, element := range a {
		fmt.Print(index, ") ", element, "\n")
	}
}



// Make a program that divides x by 2 if it’s greater than 0

package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Print("Enter a number: ")
	str1, _ := reader.ReadString('\n')

	str1 = strings.Replace(str1, "\n", "", -1)

	var x int

	// convert string variable to int variable
	num, e := strconv.Atoi(str1)
	if e != nil {
		fmt.Println("conversion error:", str1)
	}

	if num > 0 {
		x = num / 2
	} else {
		fmt.Println("Number is less than 0")
	}

	fmt.Println(x)
}


FILES

The following golang code will check if the specified file exists or not.

package main

import (
	"fmt"
	"os"
)

func main() {

	if _, err := os.Stat("Questions and Answers.txt"); err == nil {
		fmt.Printf("File exists\n")
	} else {
        
		fmt.Printf("File does not exist\n")
	}
}


STRUCT

A struct can bundle attributes together. If you create a struct,
you can set a couple of variables for that struct. Those variables can be of any datatype.

A key difference from an array is that elements of an array are all of the same datatype.
That is not the case with a struct.

If you want to combine variables, structs are the way to go. Unlike the concept of object
oriented programming, they are just data holders.


//Create a struct house with variables noRooms, price and city
//The golang example creates a new struct. Then it sets the variables.

package main

import "fmt"

type Person struct {
	name string
	job  string
}

type House struct {
	noRooms bool
	price   int
	city    string
}

func main() {
	var aperson Person

	aperson.name = "Albert"
	aperson.job = "Professor"

	fmt.Printf("aperson.name =  %s\n", aperson.name)
	fmt.Printf("aperson.job  =  %s\n\n", aperson.job)

	var inDaHouse House

	inDaHouse.noRooms = true
	inDaHouse.price = 23
	inDaHouse.city = "Accra"

	fmt.Printf("Information on the house\n")
	fmt.Printf("Are there available rooms in the house? %v \n", inDaHouse.noRooms)
	fmt.Printf("The price is Ghc%d\n", inDaHouse.price)
	fmt.Printf("The house is located in %v \n", inDaHouse.city)
}


MAPS

A Golang map is a unordered collection of key-value pairs. For every key, 
there is a unique value. If you have a key, you can lookup the value in a map.

Sometimes its called an associative array or hash table. An example of a map in Go:


elements := make(map[string]string)

Its defines as a string to string mapping. In this example we’ll use the periodic elements.

You can map on other variable types too. Below an example of string to int mapping:


alpha := make(map[string]int)
alpha["A"] = 1

alpha := map[string]int{
    "A" : 1,
    "B" : 2,
    "C" : 3,
}

RANDOM NUMBERS

In Golang, the math/rand package provides functions for generating random numbers. 
Here’s a quick guide on how to use this package to generate random numbers.

Before generating random numbers, you need to set the seed value. 
The seed value is used as the starting point for generating random numbers. 
If you set the same seed value, you’ll get the same sequence of random numbers 
every time you run your program. To set the seed, 

//use the rand.Seed() function:

In the example below, we’re setting the seed to the current Unix timestamp in nanoseconds. 
This ensures that the seed value is different every time the program runs.

rand.Seed(time.Now().UnixNano())

// To generate a unique ID, you can use a combination of random integers and
// the strconv package to convert the integers to strings:

package main

import (
	"fmt"
	"math/rand"
	"strconv"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	// generate a random 8-digit ID
	id := ""
	for i := 0; i < 8; i++ {
		id += strconv.Itoa(rand.Intn(10))
	}

	fmt.Println(id)
}


//generating a random number between 0 and 10

package main

import (
	"fmt"
	"math/rand"
	"time"
)

func random(min int, max int) int {
	return rand.Intn(max-min) + min
}

func main() {
	rand.Seed(time.Now().UnixNano())
	randomNum := random(0, 10)
	fmt.Printf("Random number: %d\n", randomNum)
}



//generating random floats between 0.0 and 1.0
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	// generate random float between 0.0 and 1.0
	randFloat := rand.Float64()

	fmt.Println("Random float between 0.0 and 1.0:", randFloat)
}


POINTERS

A pointer is a variable whose address is the direct memory address of another variable.

The asterisk * is used to declare a pointer. The form is:


var var_name *var-type

You have to write the variable type,


/* pointer to an integer */
var ipointer *int        

/* pointer to a float */
var fpointer *float32    